### 子组件为何不可以修改父组件传递的Props，如果修改了，Vue是如何监控到属性的修改并给出警告的？ 

子组件不能修改父组件传递的props是因为props是只读的，如果子组件修改了props，那么父组件也无法感知到，这就造成了数据不一致的问题。
单向数据流式自上而下，子组件需要修改值则需要子组件触发事件，而父组件来监听这个时间，然后由父组件来修改原始数据。

VUe监控到到props被需改的情况，即Vue响应式系统起来作用。Vue初始化组件时，会对props进行响应式处理。每个prpp会被定义为组件实例上的
一个响应式属性，当子组件尝试修改这个值时，VUe相式检测到会发出警告。

### 扩展Personallnfo Demo对手机号做非空且合法校验，如不合法，则给出错误提示
首先，需要确定需求：非空校验和合法性校验。
接下来，考虑如何在Vue中实现表单验证。两种方法：Vue的内置验证或第三方库。
总结步骤：
- 数据绑定:v-model绑定phone  phoneError存储验证错误信息
- 验证方法：检查非空和正则匹配
- 错误提示：根据验证结果显示信息
- 表单提交处理：阻止无效


### 相同名称的插槽是合并还是替换？
结论：
Vue的插槽机制中，同名插槽会被父组件内容全部替换，且父组件内容会在每个同名插槽位置独立渲染。

合并的例外情况
替换行为：父组件多次定义同名插槽时，后者覆盖前者。
填充行为：子组件多个同名插槽会共享父组件传递的同一内容。

当子组件存在多个相同名称的插槽时，父组件提供的对应插槽内容会替换所有的同名插槽的位置，而不是合并。


### 数组有哪些方法支持响应式更新，如不支持如何处理，底层原理如何实现的？

一，Vue中支持响应式更新的数组方法有：
```
push() // 尾部添加元素
pop()  // 尾部删除元素
shift()  // 头部删除元素
unshift() // 头部添加元素
splice()  // 添加/删除/替换元素
sort()  // 排序
reverse()  // 反转

```

代码验证：
```
//Vue组件中
methods: {
    updateArray() {
        this.list.push('newItem'):
    }
  }
```
二，数组不支持响应式更新的操作
<b>不会触发视图更新</b>
```
//1.直接通过索引修改
this.list[0] = 'newItem'; //不会触发视图更新

//2.直接修改数组长度
this.list.length = 0; //不会触发视图更新

//3.通过splice修改数组
this.list  = this.list.filter(item => item.valid); 需要重新赋值


```

三，使用强制更新方法：
方案1：使用Vue.set/this.$set
```
//修改索引对应的值
this.$set(this.list, 0, 'newItem');

//动态添加属性同理
this.$set(this.obj, 'newProp', 'newValue')
```

方案2：调用变异方法
```
//通过splice替换元素
this.list.splice(0, 1, 'newItem');

//清空数组
this.list.splice(0);

```

方案3：返回新数组（推荐不可变编程）
```
//使用filter/map等方法返回新数组
this.list = this.list.map(item => ({...item, active: true}));
```

四，底层响应式原理实现
1.拦截数组原型
2.覆盖数组原型